<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex">  <meta name="built-on" content="2023-11-05T19:06:08.718751"><meta name="build-number" content="${buildNumber}">       <title>Building applications | Dapr demo</title><script id="virtual-toc-data" type="application/json">[{"id":"key-terminology","level":0,"title":"Key terminology","anchor":"#key-terminology"},{"id":"the-applications","level":0,"title":"The applications","anchor":"#the-applications"},{"id":"solution-structure","level":0,"title":"Solution structure","anchor":"#solution-structure"},{"id":"docker-containers","level":0,"title":"Docker containers","anchor":"#docker-containers"},{"id":"daprize-the-applications","level":0,"title":"Daprize the applications","anchor":"#daprize-the-applications"},{"id":"service-to-service-building-block","level":0,"title":"Service-to-service building block","anchor":"#service-to-service-building-block"},{"id":"configuration-management-building-block","level":0,"title":"Configuration management building block","anchor":"#configuration-management-building-block"},{"id":"secrets-management-building-block","level":0,"title":"Secrets management building block","anchor":"#secrets-management-building-block"},{"id":"pub-sub-building-block","level":0,"title":"Pub-Sub building block","anchor":"#pub-sub-building-block"}]</script><script id="topic-shortcuts" type="application/json"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.1.5-b176/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Building applications | Dapr demo"/><meta property="og:description" content=""/><meta property="og:image" content=""/><meta property="og:site_name" content="Dapr demo Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="building-applications.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Building applications | Dapr demo"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "building-applications.html#webpage", "url": "building-applications.html", "name": "Building applications | Dapr demo", "description": "", "image": "", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "/#website", "url": "/", "name": "Dapr demo Help" }</script><!-- End Schema.org --> <!-- Mermaid light/dark themes -->  <link rel="stylesheet" type="text/css" href="mermaid.css">  </head>     <body data-id="Building-applications" data-main-title="Building applications" data-article-props="{&quot;seeAlso&quot;:[{&quot;title&quot;:&quot;External links&quot;,&quot;links&quot;:[{&quot;url&quot;:&quot;https://github.com/dapr/components-contrib/blob/master/configuration/azure/appconfig/appconfig.go&quot;,&quot;text&quot;:&quot;Configuration definition \n(GitHub)&quot;},{&quot;url&quot;:&quot;https://docs.dapr.io/operations/components/component-secrets/&quot;,&quot;text&quot;:&quot;Dapr Reference secrets&quot;},{&quot;url&quot;:&quot;https://cloudevents.io/&quot;,&quot;text&quot;:&quot;Cloud Events&quot;}]}],&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="Developer-experience.md|Developer experience"  >   <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Dapr demo  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="Building-applications"  id="Building-applications.md"  >Building applications</h1>  <p id="b4bdf5b4_33453">To really appreciate the simplicity that dapr provides, let's build two applications that use common components that you'd expect from any mildly complex distributed solution.</p><p id="b4bdf5b4_33454">You may write along if you wish, but I've designed this section to be more of an inspiration to how you can enable certain building blocks and the lessons I've learnt doing so.</p><p id="b4bdf5b4_33455">The exercise is designed to first write the application code, which allows you to think &quot;how would I normally enable these functionalities?&quot;, and then I'll create a component configuration that goes along with the feature.</p><aside class="prompt" data-type="tip" data-title="" id="b4bdf5b4_33456"><p id="b4bdf5b4_33457">We're building applications that use self-hosted mode. Go to the <a href="application-deployment.html" id="b4bdf5b4_33458" data-tooltip="Deploying applications to production can be a daunting task, made simpler and more manageable through the use of tools like Dapr. By abstracting away many of the problems associated with distributed systems, Dapr allows developers to focus more on writing business logic rather than&hellip;"  >Application deployment</a> chapter for production-ready examples.</p></aside><section class="chapter"><h2 id="key-terminology" data-toc="key-terminology">Key terminology</h2><p id="b4bdf5b4_33459">As with anything new, grasping key terminologies often makes the learning curve smoother and enhances understanding. At this point, you're likely familiar with most of the dapr terms, however, take a minute to review the terms below and their meaning.</p><ul class="list _ul" id="b4bdf5b4_33460"    ><li class="list__item" id="b4bdf5b4_33461"><p><span class="control" id="b4bdf5b4_33462">dot dapr (.dapr) folder</span>: a folder which holds dapr specific configurations, and is conventionally also named <code class="code" id="b4bdf5b4_33463">.dapr</code>. Individual developers may change its physical name, but should still be referred to as the &quot;dot dapr folder.&quot;</p></li><li class="list__item" id="b4bdf5b4_33464"><p><span class="control" id="b4bdf5b4_33465">Component</span>: a building block implementation, such as the &quot;secrets manager component.&quot;</p></li><li class="list__item" id="b4bdf5b4_33466"><p><span class="control" id="b4bdf5b4_33467">Project component</span>: a component that is specifically only used in a single application.</p></li><li class="list__item" id="b4bdf5b4_33468"><p><span class="control" id="b4bdf5b4_33469">Resource</span>: a broad catagorization of dapr constructs, such as &quot;multi app run file,&quot; &quot;component,&quot; and &quot;dapr API.&quot;</p></li><li class="list__item" id="b4bdf5b4_33470"><p><span class="control" id="b4bdf5b4_33471">Shared resource</span>: typically refers to a shared dapr component.</p></li><li class="list__item" id="b4bdf5b4_33472"><p><span class="control" id="b4bdf5b4_33473">Sidecar</span>: short for an application-specific &quot;dapr sidecar.&quot;</p></li></ul></section><section class="chapter"><h2 id="the-applications" data-toc="the-applications">The applications</h2><p id="b4bdf5b4_33474">We'll create two simple, arbitrary applications that communicate with each other through HTTP, gRPC, and event messages.</p><p id="b4bdf5b4_33475">The applications are not meant to model any domain, or, really make any sense. They're made purely to demonstrate dapr capabilities that are prevalent in many distributed architectures and solution designs:</p><ul class="list _ul" id="b4bdf5b4_33476"    ><li class="list__item" id="b4bdf5b4_33477"><p>Service-to-service invocation (HTTP and gRPC): how</p></li><li class="list__item" id="b4bdf5b4_33478"><p>Secrets management: dealing with securely store and retrieve secret values.</p></li><li class="list__item" id="b4bdf5b4_33479"><p>Pub/sub</p></li><li class="list__item" id="b4bdf5b4_33480"><p>Configuration management</p></li></ul><p id="b4bdf5b4_33481">The applications are containerized ASP.NET Core apps built using .NET8 preview with. One is a regular &quot;Empty&quot; ASP.NET Core app, and the other is initialized with the gRPC template.</p><p id="b4bdf5b4_33482">Each following section demonstrates a certain building block.</p></section><section class="chapter"><h2 id="solution-structure" data-toc="solution-structure">Solution structure</h2><p id="b4bdf5b4_33483">We have a single .NET solution with two projects (applications):</p><ul class="list _ul" id="b4bdf5b4_33484"    ><li class="list__item" id="b4bdf5b4_33485"><p>Users: a web api that exposes a simple HTTP API.</p></li><li class="list__item" id="b4bdf5b4_33486"><p>Accounts: a gRPC service exposing its method using a proto description file.</p></li></ul><p id="b4bdf5b4_33487">Our file structure looks like this:</p><div class="code-block" data-lang="plaintext"         >
root/
├──TheSolution.sln
├──docker-compose.yml
├──.dapr/
│   ├── dapr.yml
│   └── components/
├──src/
│   ├──Accounts/
│   │  ├──.dapr/
│   │  └──Accounts.csproj
│   │
│   └──Users/
│      ├──.dapr/
│      └──Users.csproj
</div><p id="b4bdf5b4_33489">Notice there's a dot dapr (<code class="code" id="b4bdf5b4_33490">.dapr</code>) folder in both the solution root and each project.</p><p id="b4bdf5b4_33491">The solution dot dapr is intended for gathering shared resources and solution wide files, such as the multi app run file <code class="code" id="b4bdf5b4_33492">dapr.yml</code>.</p></section><section class="chapter"><h2 id="docker-containers" data-toc="docker-containers">Docker containers</h2><p id="b4bdf5b4_33493">We need to have a few docker containers running locally to simulate actual external services that our applications can interact with through their sidecars.</p><p id="b4bdf5b4_33494">All we need is a postgres server and rabbitmq message broker running.</p><p id="b4bdf5b4_33495">You might have noticed the <code class="code" id="b4bdf5b4_33496">docker-compose.yml</code> in the solution structure. I've added the following services to the docker compose file:</p><div class="code-block" data-lang="yaml"         >
version: &quot;3.9&quot;

# Notice I've changed the default host ports
# to avoid port collisions with other running
# containers on the machine.

services:
  demo-postgressql:
    image: postgres:latest
    ports:
      - &quot;5410:5432&quot;
    environment:
      - &quot;POSTGRES_USER=postgres&quot;
      - &quot;POSTGRES_PASSWORD=postgres&quot;
  
  demo-rabbitmq:
    image: rabbitmq:3.9.29-management
    ports:
      - &quot;15699:15672&quot; # UI
    environment:
      # Showing the default username/password for
      # those who are not used to rabbitmq
      - &quot;RABBITMQ_DEFAULT_USER=guest&quot;
      - &quot;RABBITMQ_DEFAULT_PASS=guest&quot;
</div><p id="b4bdf5b4_33498">You can then start the docker containers by running <code class="code" id="b4bdf5b4_33499">docker-compose up</code> from the solution root.</p></section><section class="chapter"><h2 id="daprize-the-applications" data-toc="daprize-the-applications">Daprize the applications</h2><p id="b4bdf5b4_33500">Let's first daprize the applications. By the way, the &quot;daprize&quot; process is the same for brown-field applications.</p><p id="b4bdf5b4_33501">The first step is to create a &quot;multi app run file&quot; resource located in <code class="code" id="b4bdf5b4_33502">solution/.dapr/dapr.yml</code>. It's an appropriate first step as the file won't change much after its initial creation.</p><p id="b4bdf5b4_33503">The file primarily only changes if you need to more daprized applications.</p><div class="code-block" data-lang="yaml"         >
# Multi-App template file
# Use this file to run multiple applications at once.
# Run `dapr run --run-file dapr.yml`
version: 1
common:
#  Shared 'resourcesPath' doesn't work for apps that have its own 'resourcesPaths' defined.
  resourcesPath: components # path relative to the location of this file (dapr.yml)
apps:
  - appID: accounts-app
    appDirPath: ../src/Accounts
    appPort: 5118
    daprHTTPPort: 3500
    daprGRPCPort: 60000
    appProtocol: grpc
    daprdLogDestination: console
    appLogDestination: console
    logLevel: info
  #    command: [&quot;dotnet&quot;, &quot;watch&quot;, &quot;--non-interactive&quot;]
  - appID: users-app
    appDirPath: ../src/Users
    resourcesPaths:
      - .dapr/components
      - ../../.dapr/components
    appPort: 5214
    daprHTTPPort: 3501
    daprGRPCPort: 60001
    appProtocol: http
    enableApiLogging: true
    daprdLogDestination: console
    appLogDestination: console
    logLevel: debug
#    command: [&quot;dotnet&quot;, &quot;watch&quot;, &quot;--non-interactive&quot;]
</div><section class="chapter"><h3 id="installing-package-dependencies" data-toc="installing-package-dependencies">Installing package dependencies</h3><section class="procedure-steps" id="b4bdf5b4_33505"  ><p id="b4bdf5b4_33506">Since dapr is mostly doing all the work in the sidecar, &quot;daprizing&quot; applications is as simple as adding a few dependencies, and very little additional code.</p><ol class="list _decimal"><li class="list__item" id="b4bdf5b4_33507"><p id="b4bdf5b4_33508">To take full advantage of the dapr building blocks, we'll need to install a few dependencies:</p><div class="code-block" data-lang="markup"         >
&lt;PackageReference Include=&quot;Dapr.AspNetCore&quot; Version=&quot;1.12.0&quot; /&gt;
&lt;PackageReference Include=&quot;Dapr.Extensions.Configuration&quot; Version=&quot;1.12.0&quot; /&gt;
</div></li><li class="list__item" id="b4bdf5b4_33510"><p id="b4bdf5b4_33511">Then add dapr client to the dependency injection container.</p><div class="code-block" data-lang="csharp"         >
builder.Services.AddDaprClient();
</div></li></ol></section><p id="b4bdf5b4_33513">This is all the setup we need for now. We'll add additional setup as we onboard new components.</p></section><section class="chapter"><h3 id="run-the-sidecars" data-toc="run-the-sidecars">Run the sidecars</h3><p id="b4bdf5b4_33514">As you develop your application, you can have the dapr sidecars running. The only time you need to restart the sidecars is when you're making dapr-specific changes such as component updates.</p><p id="b4bdf5b4_33515">Run <code class="code" id="b4bdf5b4_33516">dapr run -f .dapr/dapr.yml</code></p></section></section><section class="chapter"><h2 id="service-to-service-building-block" data-toc="service-to-service-building-block">Service-to-service building block</h2><p id="b4bdf5b4_33517">Let's understand how the service-to-service invocation building block works, and see if it differs from regular web api interactions.</p><p id="b4bdf5b4_33518">I've created the following controller and action in the <code class="code" id="b4bdf5b4_33519">users</code> ASP.NET Core app. Note that the app runs on port <code class="code" id="b4bdf5b4_33520">5214</code> and its sidecar on port <code class="code" id="b4bdf5b4_33521">3501</code>.</p><div class="code-block" data-lang="csharp"         >
[ApiController]
[Route(&quot;[controller]&quot;)]
public class UsersController(ILogger&lt;UsersController&gt; logger) : ControllerBase
{
    [HttpGet(&quot;Me&quot;)]
    public IActionResult GetMe()
    {
        return Ok(new MeResponse(Guid.NewGuid(), &quot;demo-user&quot;));
    }
}

public record MeResponse(Guid Id, string Username);
</div><section class="chapter"><h3 id="http-call" data-toc="http-call">HTTP call</h3><p id="b4bdf5b4_33523">You can start the application locally as you'd always do, and hit this endpoint with:</p><ul class="list _ul" id="b4bdf5b4_33524"    ><li class="list__item" id="b4bdf5b4_33525"><p>an http request</p></li><li class="list__item" id="b4bdf5b4_33526"><p>using dapr resources such as the dapr cli</p></li><li class="list__item" id="b4bdf5b4_33527"><p>and requests directly to the sidecar.</p></li></ul><div class="tabs" id="b4bdf5b4_33528"><div class="tabs__content" data-gtm="tab" id="b4bdf5b4_33529"   data-title="HTTP curl" ><div class="code-block" data-lang="http"    data-title="HTTP"     >
curl http://localhost:5214/users/me
</div><p id="b4bdf5b4_33531">A simple curl request works as expected. Nothing has changed, even though we're also using dapr.</p></div><div class="tabs__content" data-gtm="tab" id="b4bdf5b4_33532"   data-title="Dapr CLI" ><div class="code-block" data-lang="bash"    data-title="Shell"     >
dapr invoke --app-id users-app -m /users/me -v GET --log-as-json
</div><p id="b4bdf5b4_33534">You can use the dapr cli when testing locally. Using <code class="code" id="b4bdf5b4_33535">--log-as-json</code> is great for debugging potential dapr configuration errors.</p><p id="b4bdf5b4_33536">Also, dapr defaults to <code class="code" id="b4bdf5b4_33537">POST</code> requests. You have to explicitly tell the cli to use <code class="code" id="b4bdf5b4_33538">GET</code>.</p></div><div class="tabs__content" data-gtm="tab" id="b4bdf5b4_33539"   data-title="Dapr Sidecar" ><p>The more interesting bit is how the sidecar works, since this is how your applications are going to interact with each other. This can be done in two ways: </p><div class="code-block" data-lang="none"    data-title="None"     >
curl http://localhost:3501/v1.0/invoke/users-app/method/users/me
</div><p id="b4bdf5b4_33541">or by using http headers:</p><div class="code-block" data-lang="none"    data-title="None"     >
curl -H 'dapr-app-id: users-app' http://localhost:3501/users/me
</div><p id="b4bdf5b4_33543">Notice we're making a regular HTTP request, but this time directed at the user application's sidecar, running on port <code class="code" id="b4bdf5b4_33544">3501</code>.</p><p id="b4bdf5b4_33545">Using the http header <code class="code" id="b4bdf5b4_33546">dapr-app-id</code> may produce a nice-looking url, but this approach also requires you to add dapr specific headers in your code.</p></div></div><section class="chapter"><h4 id="http-code-implementation" data-toc="http-code-implementation">HTTP code implementation</h4><p id="b4bdf5b4_33547">With this new knowledge, let's see how the <span class="control" id="b4bdf5b4_33548"><code class="code" id="b4bdf5b4_33549">accounts</code></span> app can call our <code class="code" id="b4bdf5b4_33550">users</code> app.</p><p id="b4bdf5b4_33551">It's important to note that the <code class="code" id="b4bdf5b4_33552">accounts</code> app's sidecar runs on port <code class="code" id="b4bdf5b4_33553">3500</code>.</p><aside class="prompt" data-type="tip" data-title="" id="b4bdf5b4_33554"><p id="b4bdf5b4_33555">Remember, the <code class="code" id="b4bdf5b4_33556">accounts</code> app is a gRPC API using a protobuf description. The description file isn't important at this point.</p></aside><p id="b4bdf5b4_33557">Just like before, we have several ways of achieving the same, when calling another service:</p><ol class="list _decimal" id="b4bdf5b4_33558"  type="1"  ><li class="list__item" id="b4bdf5b4_33559"><p>Use <code class="code" id="b4bdf5b4_33560">DaprClient</code>'s <code class="code" id="b4bdf5b4_33561">InvokeMethodAsync</code> method. This is very restrictive, and I think this should generally be avoided.</p></li><li class="list__item" id="b4bdf5b4_33562"><p>Create an <code class="code" id="b4bdf5b4_33563">Invoke method request</code> using the same <code class="code" id="b4bdf5b4_33564">DaprClient</code>. This is preferred over using <code class="code" id="b4bdf5b4_33565">InvokeMethodAsync</code> because we have more flexibility, and it allows us to add additional headers.</p></li><li class="list__item" id="b4bdf5b4_33566"><p>The &quot;dapr native&quot; way by creating an &quot;Invoker http client&quot; which dapr configures for us. This approach allows nice-looking URLs and provides us with flexibility because we're essentially dealing with an almost regular <code class="code" id="b4bdf5b4_33567">HttpClient</code>.</p></li><li class="list__item" id="b4bdf5b4_33568"><p>Use a language native <code class="code" id="b4bdf5b4_33569">HttpClient</code>. This is my preferred option since we've no reliance on external code. We simply make a regular HTTP call to the sidecar.</p></li></ol><p id="b4bdf5b4_33570">Take a second to review the code below which exemplifies the four approaches.</p><div class="code-block" data-lang="csharp"         >
public class GreeterService(DaprClient client) : Greeter.GreeterBase
{
    /// &lt;summary&gt;
    /// Demonstrating four different ways to invoke an other service with the dapr sidecar. 
    /// &lt;/summary&gt;
    public override async Task&lt;HelloReply&gt; SayHello(HelloRequest request, ServerCallContext context)
    {
        // 1.   The simplest is to use the DaprClient's InvokeMethodAsync method.
        //      This is provides very limited functionality and should be avoided.  
        MeResponse? simpleInvoke = await client.InvokeMethodAsync&lt;MeResponse&gt;(
            HttpMethod.Get,
            &quot;users-app&quot;,
            &quot;users/me&quot;
        );
        
        
        // 2.   Create an Invoke request that
        //      This allows us more control over the request itself.
        //      Useful when you want to include additional headers.
        HttpRequestMessage invokeRequest = client.CreateInvokeMethodRequest(
            HttpMethod.Get,
            &quot;users-app&quot;,
            &quot;users/me&quot;
        );
        invokeRequest.Headers.Authorization = new AuthenticationHeaderValue(&quot;Bearer&quot;, &quot;some jwt&quot;);
        MeResponse? response = await client.InvokeMethodAsync&lt;MeResponse&gt;(invokeRequest);
        
        // 3.   Use the &quot;Dapr native&quot; HttpClient
        //      Since the method 'CreateInvokeHttpClient' returns a regular
        //      HttpClient, you have almost full control.
        HttpClient? invoker = DaprClient.CreateInvokeHttpClient();
        var invokerResponse = await invoker.GetFromJsonAsync&lt;MeResponse&gt;(
            &quot;http://users-app/users/me&quot;
        );
        
        // 4.   Use the language native way.
        //      Full flexibility and no use of dapr-specific methods.
        var httpClient = new HttpClient
        {
            BaseAddress = new Uri(&quot;http://localhost:3500&quot;),
            DefaultRequestHeaders = { { &quot;User-Agent&quot;, typeof(GreeterService).Assembly.GetName().Name } },
        };
        
        HttpResponseMessage result = await httpClient.GetAsync(
            &quot;v1.0/invoke/users-app/method/Users/Me&quot;
        );
        string body = await result.Content.ReadAsStringAsync();

        return new HelloReply
        {
            Message = $&quot;WebAPI: Hello {request.Name}&quot;
        };
    }

    public override Task&lt;GoodbyeReply&gt; SayGoodbye(GoodbyeRequest request, ServerCallContext context)
    {
        // Keep empty for now
        return base.SayGoodbye(request, context);
    }
}

public record MeResponse(Guid Id, string Username);
</div><p id="b4bdf5b4_33572">That's generally how you'd do service-to-service calls over HTTP. The dapr sidecar provides a huge benefit in distributed systems, because services no longer need to know the address over other services. The sidecar will make things happen for you.</p></section></section><section class="chapter"><h3 id="grpc-call" data-toc="grpc-call">gRPC call</h3><p id="b4bdf5b4_33573">gRPC services are defined using proto descriptions. Here's the <code class="code" id="b4bdf5b4_33574">accounts</code> app's proto file:</p><div class="code-block" data-lang="plaintext"         >
syntax = &quot;proto3&quot;;

option csharp_namespace = &quot;Accounts&quot;;

package greet;

service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply);
  rpc SayGoodbye (GoodbyeRequest) returns (GoodbyeReply);
}

message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}

message GoodbyeRequest { }

message GoodbyeReply {
  string message = 1;
}
</div><p id="b4bdf5b4_33576">This allows us to invoke the services <code class="code" id="b4bdf5b4_33577">SayHello</code> and <code class="code" id="b4bdf5b4_33578">SayGoodbye</code> with the sidecar. However, the dapr cli doesn't seem to support gRPC invocation at this point.</p><section class="chapter"><h4 id="grpc-code-implementation" data-toc="grpc-code-implementation">gRPC code implementation</h4><p id="b4bdf5b4_33579">Let's see how the <code class="code" id="b4bdf5b4_33580">users</code> app can make gRPC calls to the <code class="code" id="b4bdf5b4_33581">accounts</code> app.</p><p id="b4bdf5b4_33582">This proto description file needs to be present in the <code class="code" id="b4bdf5b4_33583">users</code> app. I've created the file in <code class="code" id="b4bdf5b4_33584">./src/users/Protos/greet.proto</code>. Then, I've also configured the <code class="code" id="b4bdf5b4_33585">users</code> app to act as a gRPC client, but adding the following to the <code class="code" id="b4bdf5b4_33586">Users.csproj</code>:</p><div class="code-block" data-lang="markup"         >
&lt;ItemGroup&gt;
  &lt;PackageReference Include=&quot;Grpc.Net.Client&quot; Version=&quot;2.59.0-pre1&quot; /&gt;
  &lt;PackageReference Include=&quot;Grpc.Tools&quot; Version=&quot;2.59.0&quot;&gt;
    &lt;PrivateAssets&gt;all&lt;/PrivateAssets&gt;
    &lt;IncludeAssets&gt;runtime; build; native; contentfiles; analyzers; buildtransitive&lt;/IncludeAssets&gt;
  &lt;/PackageReference&gt;
&lt;/ItemGroup&gt;

&lt;ItemGroup&gt;
  &lt;Protobuf Include=&quot;Protos\greet.proto&quot;&gt;
    &lt;!-- Notice the &quot;Client&quot; here --&gt;
    &lt;GrpcServices&gt;Client&lt;/GrpcServices&gt;
    &lt;Access&gt;Public&lt;/Access&gt;
    &lt;ProtoCompile&gt;True&lt;/ProtoCompile&gt;
    &lt;CompileOutputs&gt;True&lt;/CompileOutputs&gt;
    &lt;OutputDir&gt;obj\Debug/net8.0/&lt;/OutputDir&gt;
    &lt;Generator&gt;MSBuild:Compile&lt;/Generator&gt;
  &lt;/Protobuf&gt;
&lt;/ItemGroup&gt;
</div><p id="b4bdf5b4_33588">Alright, with all the configuration out of the way, we can finally get to call the gRPC service. You'll see that calling a gRPC service through the sidecar doesn't provide as many options as with HTTP.</p><p id="b4bdf5b4_33589">All you do is make a regular gRPC call with an added <code class="code" id="b4bdf5b4_33590">dapr-app-id</code> header to the <code class="code" id="b4bdf5b4_33591">users</code> app sidecar running on port <code class="code" id="b4bdf5b4_33592">60001</code>.</p><div class="code-block" data-lang="csharp"         >
// Added enpoint in 
[HttpGet(&quot;Remote&quot;)]
public async Task&lt;IActionResult&gt; CallRemote()
{
    GrpcChannel channel = GrpcChannel.ForAddress(&quot;http://localhost:60001&quot;);
    var c = new Greeter.GreeterClient(channel);

    var meta = new Metadata
    {
        { &quot;dapr-app-id&quot;, &quot;accounts-app&quot; }
    };
    GoodbyeReply? response = await c.SayGoodbyeAsync(new GoodbyeRequest(),meta);

    return Ok();
}
</div><p id="b4bdf5b4_33594">Alright, now you've seen how the service-to-service building block works.</p></section></section></section><section class="chapter"><h2 id="configuration-management-building-block" data-toc="configuration-management-building-block">Configuration management building block</h2><p id="b4bdf5b4_33595">Applications often need flexible configurations that can change without having to modify code, restart, or redeploy. That's where the dapr configuration component comes in handy.</p><section class="chapter"><h3 id="preparing-the-app-for-configurations" data-toc="preparing-the-app-for-configurations">Preparing the app for configurations</h3><p id="b4bdf5b4_33596">Say we want to let the <code class="code" id="b4bdf5b4_33597">users</code> app dynamically change the <code class="code" id="b4bdf5b4_33598">username</code> output from the <code class="code" id="b4bdf5b4_33599">/users/me</code> endpoint. We'll first make a few changes to the <code class="code" id="b4bdf5b4_33600">users</code> app. Notice that none of these changes are dapr specific yet.</p><ol class="list _decimal" id="b4bdf5b4_33601"  type="1"  ><li class="list__item" id="b4bdf5b4_33602"><p id="b4bdf5b4_33603">Add the new configurations to the <code class="code" id="b4bdf5b4_33604">appsettings.json</code>.</p><div class="code-block" data-lang="json"         >
// appsettings.json
{
    &quot;UserConfigurations&quot;: {
        &quot;Username&quot;: &quot;demo-user&quot;
    }
}
</div></li><li class="list__item" id="b4bdf5b4_33606"><p id="b4bdf5b4_33607">Then add a configuration mapping class</p><div class="code-block" data-lang="csharp"         >
public class UserConfiguration
 {
     public string Username { get; set; }
 }
</div></li><li class="list__item" id="b4bdf5b4_33609"><p id="b4bdf5b4_33610">Wire up the <code class="code" id="b4bdf5b4_33611">UserConfiguration</code> class wit hthe dependency injection container.</p><div class="code-block" data-lang="csharp"         >
// In Program.cs
builder.Services.Configure&lt;UserConfiguration&gt;(config.GetSection(&quot;UserConfigurations&quot;));
</div></li><li class="list__item" id="b4bdf5b4_33613"><p id="b4bdf5b4_33614">Add the configuration class as a monitored option to the controller.</p><div class="code-block" data-lang="csharp"         >
public class UsersController(
    IOptionsMonitor&lt;UserConfiguration&gt; config,
    ILogger&lt;UsersController&gt; logger) : ControllerBase
{
    [HttpGet(&quot;Me&quot;)]
    public IActionResult GetMe()
    {
        return Ok(new MeResponse(
                         Guid.NewGuid(),
                         config.CurrentValue.Username)
        );
    } 
}
</div></li></ol><p id="b4bdf5b4_33616">The none-dapr specifics are now done. Let's shift our focus on creating a component configuration and setting things up to work with the Configurations building block.</p></section><section class="chapter"><h3 id="setting-up-the-configuration-component" data-toc="setting-up-the-configuration-component">Setting up the configuration component</h3><p id="b4bdf5b4_33617">Enabling the configuration component is somewhat involved since it requires us to define a component configuration, configure the application, and create a database table and trigger.</p><ol class="list _decimal" id="b4bdf5b4_33618"  type="1"  ><li class="list__item" id="b4bdf5b4_33619"><p id="b4bdf5b4_33620">Add a file in the solution's .dapr folder: <code class="code" id="b4bdf5b4_33621">./.dapr/components/configurationstore.yml</code>.</p></li><li class="list__item" id="b4bdf5b4_33622"><p id="b4bdf5b4_33623">Now configure the component like so:</p><div class="code-block" data-lang="yaml"         >
apiVersion: dapr.io/v1alpha1
kind: Component
metadata:
  name: configurationstore
spec:
  type: configuration.postgresql
  version: v1
  metadata:
    - name: connectionString
      # Port 5499 from mapped port in docker-compose
      value: &quot;host=localhost user=postgres password=postgres port=5499 connect_timeout=10 database=postgres&quot;
    - name: table
      value: &quot;configurations&quot;
    - name: subscribePollInterval
      value: 60000000000 # = 1 second
</div><p id="b4bdf5b4_33625">This tells dapr that it can find configurations using a postgres database, with the specified connectionstring and pulling configurations from the table called <code class="code" id="b4bdf5b4_33626">configurations</code>. Be aware that dapr only supports all-lowercase configuration table names.</p></li><li class="list__item" id="b4bdf5b4_33627"><p id="b4bdf5b4_33628">Then we need to set up the database to contain our &quot;configurations&quot; table and trigger to notify when changes occur. You'd want to keep this script in source control and apply as part of a migration.</p><div class="code-block" data-lang="sql"         >
CREATE TABLE IF NOT EXISTS &quot;configurations&quot;
(
    KEY      VARCHAR NOT NULL,
    VALUE    VARCHAR NOT NULL,
    VERSION  VARCHAR NOT NULL,
    METADATA JSON
);

CREATE OR REPLACE FUNCTION notify_event() RETURNS TRIGGER AS $$
DECLARE
    data json;
    notification json;

BEGIN

    IF (TG_OP = 'DELETE') THEN
        data = row_to_json(OLD);
    ELSE
        data = row_to_json(NEW);
    END IF;

    notification = json_build_object(
            'table',TG_TABLE_NAME,
            'action', TG_OP,
            'data', data);
    PERFORM pg_notify('config',notification::text);
    RETURN NULL;
END;
$$ LANGUAGE plpgsql

CREATE TRIGGER config
    AFTER INSERT OR UPDATE OR DELETE ON &quot;configurations&quot;
    FOR EACH ROW EXECUTE PROCEDURE notify_event();
</div><p id="b4bdf5b4_33630">You might want to run the dapr run file to check if your sidecars are configured correctly, and loads the new &quot;Configuration&quot; component. The sidecar shows an error in case of malconfigurations.</p></li><li class="list__item" id="b4bdf5b4_33631"><p id="b4bdf5b4_33632">Switching back to our application, you'll need to tell it how to fetch configuration values from dapr. At the moment, there seems to be a few development issues that require us to both use the <code class="code" id="b4bdf5b4_33633">AddDaprConfigurationStore()</code> <span class="emphasis" id="b4bdf5b4_33634">and</span> <code class="code" id="b4bdf5b4_33635">AddStreamingDaprConfigurationStore()</code>. I've explained why in the code.</p></li></ol><div class="code-block" data-lang="csharp"         >
const string configurationStore = &quot;configurationstore&quot;;

// Allows us to pull configuration values immediately.
builder.Configuration.AddDaprConfigurationStore(configurationStore,
    new List&lt;string&gt;(), // Empty means all keys
    daprClient,
    TimeSpan.FromSeconds(10)
);

// Allows us to listen for new and updated values in the database table.
// Adding this alone will not load the initial values.
builder.Configuration.AddStreamingDaprConfigurationStore(configurationStore,
    new List&lt;string&gt;(), // Empty means all keys
    daprClient,
    TimeSpan.FromSeconds(10),
    // pgNotifyChannel is set to the value from our
    // previous SQL script 'PERFORM pg_notify('config',notification::text);'. 
    metadata: new Dictionary&lt;string, string&gt; { { &quot;pgNotifyChannel&quot;, &quot;config&quot; } }
);

builder.Services.Configure&lt;UserConfiguration&gt;(config.GetSection(&quot;UserConfigurations&quot;));
</div></section><section class="chapter"><h3 id="change-value" data-toc="change-value">Change value</h3><p id="b4bdf5b4_33637">At this point, we'll need to rerun dapr to load the new component.</p><ol class="list _decimal" id="b4bdf5b4_33638"  type="1"  ><li class="list__item" id="b4bdf5b4_33639"><p id="b4bdf5b4_33640">After that, try call <code class="code" id="b4bdf5b4_33641">dapr invoke --app-id users-app -m /users/me -v GET</code></p></li><li class="list__item" id="b4bdf5b4_33642"><p id="b4bdf5b4_33643">Then insert a row in the &quot;configurations&quot; table:</p><div class="code-block" data-lang="sql"         >
INSERT INTO public.configurations (key, value, version, metadata) VALUES ('UserConfigurations:Username', 'my-user', '1', null);
</div></li></ol><p id="b4bdf5b4_33645">3.Then rerun <code class="code" id="b4bdf5b4_33646">dapr invoke --app-id users-app -m /users/me -v GET</code>.</p><p id="b4bdf5b4_33647">You should now see an updated value.</p></section></section><section class="chapter"><h2 id="secrets-management-building-block" data-toc="secrets-management-building-block">Secrets management building block</h2><p id="b4bdf5b4_33648">The keen reader has likely noticed that I've placed a secret value in our <code class="code" id="b4bdf5b4_33649">configurationstore.yml</code> file. Since this file is supposed to be git-committed, we'll need to strip it from secrets. Even if those secrets are just used for development.</p><p id="b4bdf5b4_33650">Managing secrets is challenging. How you manage secrets locally, in test environment, and when deployed to production also varies greatly, making things even more difficult.</p><p id="b4bdf5b4_33651">For this, you can use the Secrets Management building block for both:</p><ul class="list _ul" id="b4bdf5b4_33652"    ><li class="list__item" id="b4bdf5b4_33653"><p>Reading secrets into other dapr components,</p></li><li class="list__item" id="b4bdf5b4_33654"><p>and loading secret values into your application.</p></li></ul><section class="chapter"><h3 id="local-secrets-file" data-toc="local-secrets-file">Local secrets file</h3><p id="b4bdf5b4_33655">Storing secrets in files locally is generally fine for development purposes, but <span class="emphasis" id="b4bdf5b4_33656">never</span> check secrets into source control.</p><aside class="prompt" data-type="warning" data-title="" id="b4bdf5b4_33657"><p id="b4bdf5b4_33658">Don't use the <code class="code" id="b4bdf5b4_33659">secretstores.local.file</code> component in production. <br> See <a href="secrets-management.html" id="b4bdf5b4_33661" data-tooltip="Dealing with secrets in a production, or production-like environment deserves its own page, to make the content as foused as possible on this one task."  >secrets management instead</a>.</p></aside><section class="chapter"><h4 id="preparing-the-component" data-toc="preparing-the-component">Preparing the component</h4><ol class="list _decimal" id="b4bdf5b4_33662"  type="1"  ><li class="list__item" id="b4bdf5b4_33663"><p id="b4bdf5b4_33664">Create a project secrets component configuration in the <code class="code" id="b4bdf5b4_33665">users</code> <code class="code" id="b4bdf5b4_33666">.dapr/components</code> folder.</p><div class="code-block" data-lang="yaml"         >
apiVersion: dapr.io/v1alpha1
kind: Component
metadata:
  name: secretstore
  namespace: default
spec:
  type: secretstores.local.file
  version: v1
  metadata:
    - name: secretsFile
      # Relative to the project, and not solution root
      value: .dapr/secrets/appsettings.Secrets.json
      # Allows nested json
    - name: nestedSeparator 
      value: &quot;:&quot;
      # 'multiValued=false' allows us to access json
      # values like ConnectionStrings:Postgresql
      # which would otherwise just become &quot;Postgresql&quot;
    - name: multiValued
      value: &quot;false&quot;
</div><p id="b4bdf5b4_33668">Since secrets are typically application-specific, you'd want to place this file within the project that needs the secrets, as opposed to having this component as a shared resource between all daprized applications.</p><aside class="prompt" data-type="note" data-title="" id="b4bdf5b4_33669"><p id="b4bdf5b4_33670">The <span class="control" id="b4bdf5b4_33671">'secretsFile'</span> value is relative to the project itself and not the solution or dapr multi app run file.</p></aside></li><li class="list__item" id="b4bdf5b4_33672"><p id="b4bdf5b4_33673">In the project itself, create a file that holds secret values here <code class="code" id="b4bdf5b4_33674">.dapr/secrets/appsettings.Secrets.json</code>, containing whatever values your application might need, such as a connection string or private key.</p><div class="code-block" data-lang="json"         >
// appsettings.Secrets.json 
// placed in the project .dapr/secrets folder
{
  &quot;ConnectionStrings&quot;: {
    &quot;Postgresql&quot;: &quot;My secret connectionstring to postgresql&quot;
  }
}
</div></li><li class="list__item" id="b4bdf5b4_33676"><p id="b4bdf5b4_33677">git-ignore the <code class="code" id="b4bdf5b4_33678">appsettings.Secrets.json</code> making sure it doesn't make its way into the git repository.</p></li><li class="list__item" id="b4bdf5b4_33679"><p id="b4bdf5b4_33680">It's a good practice to quickly see if dapr picks up your new components. Running the dapr run file gives us this:</p><div class="code-block" data-lang="plaintext"         >
INFO[0000] Component loaded: secretstore (secretstores.local.file/v1)  app_id=users-app
</div><p id="b4bdf5b4_33682">If you get any errors, it's worth paying close attention to paths, folders, and their relative position.</p></li><li class="list__item" id="b4bdf5b4_33683"><p id="b4bdf5b4_33684">Let's get rid of the connection string in the &quot;Configuration&quot; component file. Update the component to reference the <code class="code" id="b4bdf5b4_33685">ConnectionStrings:Postgresql</code> secret value.</p><div class="code-block" data-lang="yaml"         >
# omitted other values
  metadata:
    - name: connectionString
      secretKeyRef:
        name: &quot;ConnectionStrings:Postgresql&quot;
        key: &quot;ConnectionStrings:Postgresql&quot;
auth:
  secretStore: secretstore
</div><p id="b4bdf5b4_33687">There are two important changes here, compared to the original yaml: observe the connectionstring now references a secret with <code class="code" id="b4bdf5b4_33688">secretKeyRef</code> having both <code class="code" id="b4bdf5b4_33689">name</code> and <code class="code" id="b4bdf5b4_33690">key</code> set with identical values. Secondly, I've added an <code class="code" id="b4bdf5b4_33691">auth</code> element which is set to the exact same name as our secrets component's name.</p></li></ol></section></section><section class="chapter"><h3 id="preparing-the-application" data-toc="preparing-the-application">Preparing the application</h3><ol class="list _decimal" id="b4bdf5b4_33692"  type="1"  ><li class="list__item" id="b4bdf5b4_33693"><p id="b4bdf5b4_33694">First off, to be a good citizen, let's tell our colleagues that they now need to use .dapr secrets by making it explicit within the appsettings.json.</p><div class="code-block" data-lang="json"         >
// appsettings.json in the Users application.
{
  // other settings
  &quot;ConnectionStrings&quot;: {
    &quot;Postgresql&quot;: &quot;use .dapr/secrets/appsettings.Secrets.json&quot;
  }
}
</div><p id="b4bdf5b4_33696">There's almost nothing more annoying than chasing down settings loaded from various sources. Establishing clear and direct configurations promotes scalability and enhances collaborative efforts.</p></li><li class="list__item" id="b4bdf5b4_33697"><p id="b4bdf5b4_33698">Configure the application to have secrets loaded in at start-up.</p><div class="code-block" data-lang="csharp"         >
// In 'Users' Program.cs
builder.Configuration.AddDaprSecretStore(
    &quot;secretstore&quot;,
    daprClient,
    TimeSpan.FromSeconds(10)
);
string? connectionString = builder.Configuration
                                  .GetConnectionString(&quot;Postgresql&quot;);
</div><p id="b4bdf5b4_33700">The <code class="code" id="b4bdf5b4_33701">daprClient</code> is the same we instantiated during the &quot;Configuration building block&quot; steps. Also, take note of the <code class="code" id="b4bdf5b4_33702">secretstore</code> name, passed as first parameter. This name must match the <code class="code" id="b4bdf5b4_33703">metadata.name</code> from the secrets component.</p><p id="b4bdf5b4_33704">The <code class="code" id="b4bdf5b4_33705">TimeSpan.FromSeconds(10)</code> means we're willing to wait 10 seconds for the sidecar to respond with the values.</p></li></ol><p id="b4bdf5b4_33706">We've now demonstrated how to implement and use the &quot;Secrets management&quot; dapr building block and component, both in terms of accessing secret values within the application at runtime, and as Reference secrets in other dapr components.</p></section></section><section class="chapter"><h2 id="pub-sub-building-block" data-toc="pub-sub-building-block">Pub-Sub building block</h2><p id="b4bdf5b4_33707">The Publish-Subscriber pattern is prevalent in many distributed architectures and solution designs, and dapr makes it easier than ever to implement message-based communication.</p><section class="chapter"><h3 id="preparing-the-pub-sub-component" data-toc="preparing-the-pub-sub-component">Preparing the pub-sub component</h3><p id="b4bdf5b4_33708">To start off with, we need to prepare the pub-sub component. We've already set ourselves up RabbitMQ earlier, in the <code class="code" id="b4bdf5b4_33709">docker-compose</code> file. Now it's just a matter of defining our component configurations.</p><ol class="list _decimal" id="b4bdf5b4_33710"  type="1"  ><li class="list__item" id="b4bdf5b4_33711"><p id="b4bdf5b4_33712">Create a pub-sub component in the solution <code class="code" id="b4bdf5b4_33713">.dapr/components</code> folder called <code class="code" id="b4bdf5b4_33714">pubsub.yml</code>.</p><div class="code-block" data-lang="yaml"         >
# pubsub.yml
apiVersion: dapr.io/v1alpha1
kind: Component
metadata:
   name: pubsub
spec:
   type: pubsub.rabbitmq
   version: v1
   metadata:
      - name: connectionString
        value: &quot;amqp://localhost:5672&quot;
      - name: protocol
        value: amqp
      - name: hostname
        value: localhost
      - name: password
        value: guest
      - name: username
        value: guest
</div><aside class="prompt" data-type="tip" data-title="" id="b4bdf5b4_33716"><p id="b4bdf5b4_33717">To keep things focused on pub-sub here in this exercise, I've decided not to load sensitive values from the secrets component.</p></aside></li><li class="list__item" id="b4bdf5b4_33718"><p id="b4bdf5b4_33719">Try to rerun your dapr run file. You should see the sidecar picks up the new component. Then go to the rabbitmq management interface, and verify that the sidecar has an active connection. <figure  id="b4bdf5b4_33720"><img alt="rabbitmq" title="rabbitmq" src="images/rabbitmq.png"  class="" width="607" height="300"/></figure></p></li></ol><p id="b4bdf5b4_33721">The pub-sub component is quite simple to integrate with and doesn't require much else.</p></section><section class="chapter"><h3 id="preparing-the-app-for-pub-sub" data-toc="preparing-the-app-for-pub-sub">Preparing the app for pub/sub</h3><p id="b4bdf5b4_33722">How you deal with events at the application level is somewhat different than what I've usually been used to.</p><p id="b4bdf5b4_33723">The usual experience goes something like this: create a connection, then grab a channel, declare an exchange and a queue and bind those two. After that, you need to create a consumer that listens to events that are routed to the queue.</p><p id="b4bdf5b4_33724">All this is gone. With dapr, events are routed to a regular web API endpoint.</p><ol class="list _decimal" id="b4bdf5b4_33725"  type="1"  ><li class="list__item" id="b4bdf5b4_33726"><p id="b4bdf5b4_33727">Our next step is to prepare the <code class="code" id="b4bdf5b4_33728">Users</code> app, enabling the sidecar to send events to the app.</p></li><li class="list__item" id="b4bdf5b4_33729"><p id="b4bdf5b4_33730">Add a few configuration lines to the <code class="code" id="b4bdf5b4_33731">Program.cs</code> file.</p><div class="code-block" data-lang="csharp"         >
// After app.MapControllers();
app.UseCloudEvents();
app.MapSubscribeHandler();
</div></li><li class="list__item" id="b4bdf5b4_33733"><p id="b4bdf5b4_33734">Then create an endpoint with a <code class="code" id="b4bdf5b4_33735">[Topic]</code> attribute.</p><div class="code-block" data-lang="csharp"         >
[Topic(&quot;pubsub&quot;, &quot;newevent&quot;)]
[HttpPost(&quot;newevent&quot;)]
public IActionResult Event(CloudEvent @event)
{
    logger.LogInformation(&quot;Event received!&quot;);

    return Ok();
}
</div><p id="b4bdf5b4_33737">Pay attention to the following:</p><ul class="list _ul" id="b4bdf5b4_33738"    ><li class="list__item" id="b4bdf5b4_33739"><p>The method argument <code class="code" id="b4bdf5b4_33740">CloudEvent</code>. Dapr allows us to use the [CNCF event description](https://cloudevents. io/) out-of-the-box.</p></li><li class="list__item" id="b4bdf5b4_33741"><p>The topic's first argument is the pubsub.yml <code class="code" id="b4bdf5b4_33742">metadata.name</code> and the second is an arbitrary name of the message broker exchange that you want to pick up messages from.</p></li><li class="list__item" id="b4bdf5b4_33743"><p>The <code class="code" id="b4bdf5b4_33744">[HttpPost(&quot;newevent&quot;)]</code> attribute, where <code class="code" id="b4bdf5b4_33745">newevent</code> becomes the name of the rabbitmq exchange. There's also a rabbitmq queue created named <code class="code" id="b4bdf5b4_33746">users-app-newevent</code>.</p></li></ul></li><li class="list__item" id="b4bdf5b4_33747"><p id="b4bdf5b4_33748">Run the <code class="code" id="b4bdf5b4_33749">Users</code> app while the sidecar is running and go to the rabbitmq management interface.</p></li></ol><p id="b4bdf5b4_33750">As you can see, listening for events with dapr suddenly becomes trival, and there's no need for a lot of ceremony and boilerplate code.</p><p id="b4bdf5b4_33751">Since we're expected cloud-event messages, the messages need to conform to a specific format:</p><div class="code-block" data-lang="json"         >
// Example message you can post on the queue
{
   &quot;specversion&quot; : &quot;1.0&quot;,
   &quot;type&quot; : &quot;my-event-type&quot;,
   &quot;source&quot; : &quot;/mycontext&quot;,
   &quot;id&quot; : &quot;B234-1234-1234&quot;,
   &quot;time&quot; : &quot;2018-04-05T17:31:00Z&quot;,
   &quot;datacontenttype&quot; : &quot;application/json&quot;,
   &quot;data&quot; : {
      &quot;exampleKey&quot; : &quot;exampleValue&quot;
   }
}
</div></section></section><div class="last-modified"> Last modified: 05 November 2023</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="getting-started.html">Getting started with dapr</a>   <a class="navigation-links__next" href="application-deployment.html">Application deployment</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/writerside/apidoc/6.1.5-b176/app.js"></script></body></html>